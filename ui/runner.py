import random
from threading import Event, Lock
from queue import Queue, Empty

from comfy_nodes import queue
from utils import make_output_text, make_name
from workflow.core import CharacterWorkflow
from workflow.caption import CaptionWorkflow


class WorkflowRunner:
    def __init__(self):
        self._preview_lock = Lock()
        self._latest_preview = None
        self._stop_event = Event()
        self._stop_wf = False

        self._task_queue = Queue()
        self._task_lock = Lock()
        self._current_id = 0

    def _push_preview(self, task, node_id, image):
        with self._preview_lock:
            self._latest_preview = image

    def _reset_preview(self):
        with self._preview_lock:
            self._latest_preview = None

    async def queue(self, in_state: dict):
        char = make_name(in_state["character"])
        in_state["base_seed"] = (
            random.randint(0, int(1e10))
            if in_state["base_seed"] == -1
            else in_state["base_seed"]
        )
        in_state["perturb_seed"] = (
            random.randint(0, int(1e10))
            if in_state["perturb_seed"] == -1
            else in_state["perturb_seed"]
        )

        wf = CharacterWorkflow(in_state)

        out_text = make_output_text(wf.ctx)

        result_list = await wf.queue(in_state["process_controller"])

        for result, label in result_list:
            with self._task_lock:
                self._task_queue.put_nowait(
                    (result, char, label, self._current_id, out_text)
                )

        self._current_id += 1

    async def generate_caption(self, in_state: dict):
        wf = CaptionWorkflow(in_state)

        caption = await wf.generate()

        if caption:
            caption = caption._output["text"][0]

            return caption
        else:
            print("No output generated by workflow")
            return ""

    def interrupt(self):
        queue.cancel_current()

    def get_preview(self):
        if self._stop_event.is_set():
            return (None, "stopped")

        with self._preview_lock:
            return (self._latest_preview, "running")

    async def get_task(self):
        try:
            with self._task_lock:
                _result, char, label, id, out_text = self._task_queue.get_nowait()

            self._reset_preview()
            self._stop_event.clear()
            _result.task.add_preview_callback(self._push_preview)
            result = await _result
            _result.task.remove_preview_callback(self._push_preview)
            image = await result

            image_size = image[0].size

            return (
                image[0],
                f"Generation {id} - {char}: {label} ({image_size[0]} x {image_size[1]})",
                out_text,
            )
        except Empty:
            self._stop_event.set()
            return None
        except TypeError as t:
            print("Workflow interrupted, moving on to next item")
            return None
